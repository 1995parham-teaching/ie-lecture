---
index: 7
title: Go Programming
topics:
  - History
  - Advantages
  - Say Hello
  - Programming Elements
  - Concurrency
---

<section>
  <h2>Gopher</h2>
  <div style="display: flex">
    <img src="./img/real-gopher.jpg" alt="real-gopher" style="height: 300px" />
    <img src="./img/gophers.png" alt="gophers" style="height: 300px" />
  </div>
</section>
<section>
  <div class="toc"></div>
</section>
<section>
  <div class="toc" data-selected="0"></div>
  <img src="img/history.png" alt="gopher-riding-rex" style="height: 10%" />
</section>
<section>
  <p><em>Go is</em></p>
  <ul>
    <li>Modern</li>
    <li>Generic Purpose</li>
    <li>Open Source</li>
  </ul>
  <p><em>Programming Language</em></p>
</section>
<section>
  <ul>
    <li>I as officially announced at November 10, 2009</li>
    <li>It began as an internal <em class="hl-orange">Google</em> project</li>
    <li>
      The designers were primarily motivated by their shared
      <strong class="hl-red">dislike of C++</strong>
    </li>
    <li>
      Its spiritual fathers are
      <ul>
        <li>Robert Griesemer</li>
        <li>Ken Thomson</li>
        <li>Rob Pike</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <ul>
    <li>
      Go is syntactically similar to C, but with
      <em class="hl-orange">memory safety</em>,
      <em class="hl-green">garbage collection</em>,
      <em class="hl-yellow">structural typing</em>, and
      <em class="hl-violet">CSP-style concurrency</em>.
    </li>
    <li>There are two major implementations:</li>
    <ol>
      <li>
        Google's self-hosting compiler toolchain targeting multiple operating
        systems, mobile devices, and WebAssembly.
      </li>
      <li>gccgo, a GCC frontend.</li>
    </ol>
  </ul>
</section>
<section>
  <ul>
    <li>Go was publicly announced in November 2009</li>
    <li>version 1.0 was released in March 2012.</li>
    <li>
      Go is widely used in production at Google and in many other organizations
      and open-source projects.
    </li>
    <li>
      Lack of support for <em class="hl-orange">generic programming</em> and
      <em class="hl-green">the verbosity of error handling</em> in Go 1.x had
      drawn considerable criticism.
    </li>
  </ul>
</section>
<section>
  <div class="toc" data-selected="1"></div>
  <img src="img/advantages.png" alt="gopher-rocks" style="height: 10%" />
</section>
<section>
  <ul>
    <li>Go code is easy to read and easy to understand</li>
    <li>Go supports Garbage Collection</li>
    <li>Go does not have a preprocssor</li>
    <li>
      Go uses static linking by default, which means that the binary files
      produced can be easily transferred to other machines with the same OS.
    </li>
  </ul>
</section>
<section>
  <section>
    <ul>
      <li>
        A syntax and environment adopting patterns more common in dynamic
        languages:
      </li>
      <ul>
        <li>
          Optional concise variable declaration and initialization through
          <em class="hl-violet">type inference</em> (<code class="hl-orange"
            >x := 0</code
          >
          instead of <code class="hl-green">int x = 0;</code>).
        </li>
        <li>Fast compilation.</li>
        <li>
          Remote package management (<code class="hl-orange">go get</code>) and
          online package documentation.
        </li>
      </ul>
    </ul>
  </section>
  <section>
    <ul>
      <li>Distinctive approaches to particular problems:</li>
      <ul>
        <li>
          Built-in concurrency primitives:
          <strong class="hl-orange">light-weight processes (goroutines)</strong
          >, <strong class="hl-green">channels</strong>, and the
          <code class="hl-yellow">select</code>
          statement.
        </li>
        <li>
          An <em class="hl-violet">interface system</em> in place of virtual
          inheritance, and <em class="hl-red">type embedding</em> instead of
          non-virtual inheritance.
        </li>
        <li>
          A toolchain that, by default, produces statically linked native
          binaries without external dependencies.
        </li>
      </ul>
      <li>
        A desire to keep the language specification simple enough to hold in a
        programmer's head, in part by omitting features that are common in
        similar languages.
      </li>
    </ul>
  </section>
</section>
<section>
  <div class="toc" data-selected="2"></div>
  <img src="img/say-hello.png" alt="teaching-gopher" style="height: 10%" />
</section>
<section>
  <pre><code class="lang-go">
package main

import "fmt"

func main() {
	fmt.Printf("Hello, World\n")
}
          </code></pre>
</section>
<section class="hands-on">
  <h2>&lt;Code Time.go&gt;</h2>
  <ul>
    <li>
      Write <strong class="hl-material">Hello World</strong> in Go but Before
      that we must install the Go! and our favorite text editor
    </li>
  </ul>
</section>
<section>
  <div class="toc" data-selected="3"></div>
</section>
<section>
  <h3>Constants</h3>
  <p>Maintained precisely:</p>
  <pre><code class="lang-go">
const e = 2.71828182845904523536028747135266249775724709369995957496696763
const third = 1/3
  </code></pre>
  <p>Typed or without type:</p>
  <pre><code class="lang-go">
const M64 int64 = 1&lt;&lt;20
const M = 1&lt;&lt;20
  </code></pre>
  <p>Evaluated at compile-time:</p>
  <pre><code class="lang-go">
const big = 1&lt;&lt;100 / 1e30  // valid constant expression
  </code></pre>
</section>
<section>
  <section>
    <h3>Variables</h3>
    <p>Statically typed:</p>
    <pre><code class="lang-go">
var x int
var s, t string
    </code></pre>
    <p>Implicitly or explicitly initialized:</p>
    <pre><code class="lang-go">
var x int
var s, t string = "foo", "bar"  // multiple assignment

var x = 42                      // int
var s, b = "foo", true          // string, bool
    </code></pre>
  </section>
  <section>
    <p>Short variable declaration (inside functions only):</p>
    <pre><code class="lang-go">
x := 42
s, b := "foo", true
    </code></pre>
    <p>
      Can safely take address of
      <em class="hl-orange">any</em> variable!
    </p>
    <pre><code class="lang-go">
return &amp;x
    </code></pre>
  </section>
</section>
<section>
  <h3>Statements</h3>
  <ul>
    <li>Curly braces (C style)</li>
    <li>Multiple assignments and some other new constructs</li>
    <li>
      Statements are <span class="material-italic">not</span> Expressions.
    </li>
    <li>
      Many cleanups:
      <ul>
        <li>mandatory braces</li>
        <li>no parentheses for conditionals</li>
        <li>implicit break in switches</li>
        <li>no semicolons</li>
        <li>...</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h3>Statements</h3>
  <pre><code class="lang-go">
a, b = b, a // swap

f, err = os.Open(filename) // multiple assignment

if x &lt; y {
	return x
} else {
	return y
}

switch day {
case Mon:
	...
  // break is implicit
case Tue, Wed:
	...
}
  </code></pre>
  <ul>
    <li>Not shown: break, goto, continue, fallthrough</li>
  </ul>
</section>
<section>
  <h3>Statements</h3>
  <ul>
    <li>Unified <code class="hl-orange">for</code> syntax</li>
    <pre><code class="lang-go">
for {
  // loop forever
}
    </code></pre>
    <li><code class="hl-orange">range</code> over arrays, slices, and maps</li>
    <pre><code class="lang-go">
for i, num := range numbers { ... }
for city, pop := range population { ... }
    </code></pre>
  </ul>
</section>
<section>
  <h3>Interaction</h3>
  <pre><code data-trim data-noescape class="go">
package "main"

import "fmt"

func main() {
  var n int
  fmt.Scanf("%d", &amp;n)
  fmt.Printf("%d\n", n)
}
  </code></pre>
</section>
<section class="hands-on">
  <h2>&lt;Code Time.go&gt;</h2>
  <ul>
    <li>
      Write a program that read n from the stdin and detects that it is a prime
      number or not.
    </li>
  </ul>
</section>
<section>
  <h2>Values</h2>
  <pre><code class="lang-go">
package main

import "fmt"

func main() {
	var a int
	a = 10
	fmt.Printf("%d\n", a)

	b := new(int)
	*b = 10
	fmt.Printf("b = %p, *b = %d\n", b, *b)
}
  </code></pre>
  <ul>
    <li>
      The <code class="hl-orange">new()</code> built-in function creates a new
      integer and returns a pointer to it.
    </li>
  </ul>
</section>
<section>
  <h2>Functions</h2>
  <pre><code class="lang-go">
package main

import "fmt"

func Fibonacci(n int) int {
	if n == 0 || n == 1 {
		return 1
	} else {
		return Fibonacci(n-1) + Fibonacci(n-2)
	}
}

func main() {
	fmt.Printf("%d\n", Fibonacci(10))
}
  </code></pre>
</section>
<section>
  <section>
    <h2>Structures</h2>
    <pre><code class="lang-go">
package main

type Sample struct {
	S1      int
	S2      int
	S3      string
	private float64
}

func main() {
	var smp Sample
	smp.S1 = 10
	smp.S2 = 20
	smp.S3 = "Hello World"
}
  </code></pre>
  </section>
  <section>
    <ul>
      <li>C Structures ðŸ•º</li>
      <li>Data hiding</li>
      <li>
        <code class="hl-orange">S1</code>, <code class="hl-orange">S2</code>,
        <code class="hl-orange">S3</code> are public and can be accessed from
        anywhere.
      </li>
      <li>
        <code class="hl-green">private</code> is private and is only visible to
        code in the same package.
      </li>
    </ul>
  </section>
</section>
<section>
  <h2>Methods</h2>
  <pre><code class="lang-go">
package main

import "fmt"

type Example struct {
	Val   string
	count int
}
type integer int

func (i integer) log() {
	fmt.Printf("%d\n", i)
}
func (e *Example) Log() {
	e.count++
	fmt.Printf("%d %s\n", e.count, e.Val)
}
func main() {
	var i integer
	exm := Example{
		Val:   "Example",
		count: 10}
	i.log()
	exm.Log()
}
    </code></pre>
</section>
<section>
  <h2>Interfaces</h2>
  <pre><code class="lang-go">
package main

import "fmt"

type Printer interface {
	Print()
}
type Foo struct {
	X, Y int
}
type Bar struct {
	X, Y float64
}

func (f Foo) Print() {
	fmt.Printf("%d %d\n", f.X, f.Y)
}
func (b Bar) Print() {
	fmt.Printf("%g %g\n", b.X, b.Y)
}
  </code></pre>
</section>
<section>
  <h2>Casting Types</h2>
  <ul>
    <li>
      type conversion: A type conversion is similar to a cast in C. It
      reinterprets the value as a new type
    </li>
  </ul>
  <pre><code class="lang-go">
package main

func main() {
	one := 1
	var float float32
	float = float32(one)
}
  </code></pre>
</section>
<section>
  <h2>Type Assertion</h2>
  <ul>
    <li>
      type assertion: They do not convert between types; they simply state to
      the compiler that the underlying value has the specific type.
    </li>
  </ul>
  <pre><code class="lang-go">
package main

import "fmt"

type empty interface{}

type example struct {
	A int
}

func main() {
	one := 1
	var i empty = one
	j := example{A: 10}
	var k empty = j
	fmt.Println(k.(example).A)
}
  </code></pre>
</section>
<section>
  <section>
    <h2>Analytic geometry</h2>
    <img src="./img/nerdy.png" alt="nerdy" style="height: 300px" />
  </section>
  <section>
    <h2>Create Point Interface</h2>
    <pre><code class="lang-go">
type Point interface {
	Distance() float64
	ImageOnX() float64
	ImageOnY() float64
}
    </code></pre>
  </section>
  <section>
    <h2>Create Catesian Point Structure</h2>
    <pre><code class="lang-go">
type Cartesian struct {
	X float64
	Y float64
}

func (c *Cartesian) Distance() float64 {
	return math.Sqrt(c.X*c.X + c.Y*c.Y)
}

func (c *Cartesian) ImageOnX() float64 {
	return c.X
}

func (c *Cartesian) ImageOnY() float64 {
	return c.Y
}
    </code></pre>
  </section>
  <section>
    <h2>Create Polar Point Structure</h2>
    <pre><code class="lang-go">
type Polar struct {
	R    float64
	Teta float64
}

func (p *Polar) Distance() float64 {
	return p.R
}

func (p *Polar) ImageOnX() float64 {
	return p.R * math.Cos(p.Teta)
}

func (p *Polar) ImageOnY() float64 {
	return p.R * math.Sin(p.Teta)
}
    </code></pre>
  </section>
  <section>
    <pre><code class="lang-go">
func main() {
	p := Polar{
		R:    1,
		Teta: math.Pi / 2,
	}

	c := Cartesian{
		X: 3,
		Y: 4,
	}

	fmt.Printf("%g %g\n", p.Distance(), c.Distance())
	fmt.Printf("%g %g\n", c.ImageOnX(), c.ImageOnY())
	fmt.Printf("%g %g\n", p.ImageOnX(), p.ImageOnY())
}
</code></pre>
  </section>
  <section>
    <a href="https://play.golang.org/p/VhSivrtSOrN">Click Me!</a>
    <pre><code class="lang-go">
package main

import (
	"fmt"
	"math"
)

type Point interface {
	Distance() float64
	ImageOnX() float64
	ImageOnY() float64
}

type Cartesian struct {
	X float64
	Y float64
}

func (c *Cartesian) Distance() float64 {
	return math.Sqrt(c.X*c.X + c.Y*c.Y)
}

func (c *Cartesian) ImageOnX() float64 {
	return c.X
}

func (c *Cartesian) ImageOnY() float64 {
	return c.Y
}

type Polar struct {
	R    float64
	Teta float64
}

func (p *Polar) Distance() float64 {
	return p.R
}

func (p *Polar) ImageOnX() float64 {
	return p.R * math.Cos(p.Teta)
}

func (p *Polar) ImageOnY() float64 {
	return p.R * math.Sin(p.Teta)
}

func main() {
	p := Polar{
		R:    1,
		Teta: math.Pi / 2,
	}

	c := Cartesian{
		X: 3,
		Y: 4,
	}

	fmt.Printf("%g %g\n", p.Distance(), c.Distance())
	fmt.Printf("%g %g\n", c.ImageOnX(), c.ImageOnY())
	fmt.Printf("%g %g\n", p.ImageOnX(), p.ImageOnY())
}
    </code></pre>
  </section>
</section>
<section>
  <section>
    <h2>Slices and Arrays</h2>
    <ul>
      <li>Slices</li>
      <pre><code class="lang-go">
[]T  // slice of T
      </code></pre>

      <li>
        <strong class="hl-orange">Descriptor</strong> for an underlying array
        segment
      </li>
      <li>
        May <em class="hl-green">grow</em> and <em class="hl-green">shrink</em>
      </li>
      <li>Has length and capacity</li>
      <li>Assigning a slice copies the descriptor, not the underlying array</li>
    </ul>
  </section>
  <section>
    <ul>
      <li>Common slice operations:</li>
      <pre><code class="lang-go">
len(s)
s[i]
s[i:j]
append(s, x)  // append element x to slice s and return new slice
      </code></pre>
      <li>Slices play the role of dynamically sized arrays</li>
      <li>Widely used in Go code</li>
    </ul>
  </section>
</section>
<section>
  <div class="toc" data-selected="4"></div>
</section>
